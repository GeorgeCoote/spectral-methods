## Mathematical pre-requisites

## High-level design decisions

* **Precision is prioritised over speed**: where possible, `Fraction` objects are used as opposed to `float`s so as to enable exact arithmetic. Complex numbers generated by class functions are typically given as tuples of `Fraction` objects, since they are known exactly. Complex numbers originating from user input are not expected to be exactly specified or exactly known and so are allowed to have `float`-type real and imaginary parts.
* **Slower reference implementations (marked by _slow) are included pedagogical purposes**: the `_slow` versions of functions represent the most straightforward, but sub-optimal, approach and serve the foundation of more optimized versions. Sometimes they represent direct translations of the pseudocode found in Colbrook and Hansen (2022). Since the pseudocode was written to most clearly demonstrate the algorithms, optimization for more practical implementation is to be expected. For example, `CompInvg_slow` represents a linear search (achieving `O(n)` time complexity), whereas `CompInvg` uses a binary search (achieving an improved `O(log n)` time complexity). The possibility of binary searches as opposed to linear searches was noted in the paper.
* **Matrices are described with `Callable`s rather than individual matrix elements**: In the Markov model of computation, matrices `(a_ij)` are described by Turing machines computing the function `(i, j) -> a_ij`. Since a `Callable` can in principle be simulated on a Turing machine, and therefore faithfully captures this theoretical setup. The `Callable` is used to generate an `np.array` where needed for numerical computations, via the `_generate_matrix` helper function.

## Example of specifying a matrix by a `Callable`

A few examples of how one may specify a matrix via a `Callable` are given below.

### Diagonal matrix 

```python
def diagonal_matrix(i : int, j : int) -> int:
  '''Generates the matrix consisting of 0, -1, 4, -9, ... on its diagonal. That is:
  [0   0    0   0  ..]
  [0   -1   0   0  ..]
  [0   0    4   0  ..]
  [0   0    0   -9 ..]
  ...
  '''
  if i == j:
    sign = (2*((i + 1)%2) - 1) # (-1)^i
    return sign*i*i # (-1)^i * i^2
  return 0
```

In this case, if `A = diagonal_matrix`, we have an exact formula for the `(i, j)`th matrix element of `A`. The only data that is stored is the code for the function `diagonal_matrix`, until an evaluation is needed by a numerical computation. More generally, one could make:

```python
def diagonal_matrix(i : int, j : int, f : Callable[[int], int]) -> int:
  return f(i) if i == j else 0
```
